// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "package:jni/jni.dart" as jni;

import "package:jni/internal_helpers_for_jnigen.dart";

final jniEnv = jni.Jni.env;
final jniAccessors = jni.Jni.accessors;

/// from: com.example.flutter_extend_mz_demo_jinigen.MyUtils
class MyUtils extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  MyUtils.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors
      .getClassOf("com/example/flutter_extend_mz_demo_jinigen/MyUtils");

  /// The type which includes information such as the signature of this class.
  static const type = $MyUtilsType();

  static final _id_showToast = jniAccessors.getStaticMethodIDOf(_classRef,
      "showToast", "(Landroid/app/Activity;Ljava/lang/CharSequence;I)V");

  /// from: static public void showToast(android.app.Activity mainActivity, java.lang.CharSequence text, int duration)
  static void showToast(
          jni.JObject mainActivity, jni.JObject text, int duration) =>
      jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_showToast,
          jni.JniCallType.voidType,
          [mainActivity.reference, text.reference, duration]).check();

  static final _id_sum =
      jniAccessors.getStaticMethodIDOf(_classRef, "sum", "()I");

  /// from: static public int sum()
  static int sum() => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_sum, jni.JniCallType.intType, []).integer;

  static final _id_sum1 =
      jniAccessors.getStaticMethodIDOf(_classRef, "sum", "(II)I");

  /// from: static public int sum(int num1, int num2)
  static int sum1(int num1, int num2) => jniAccessors.callStaticMethodWithArgs(
      _classRef, _id_sum1, jni.JniCallType.intType, [num1, num2]).integer;

  static final _id_showAlertDialog = jniAccessors.getStaticMethodIDOf(
      _classRef, "showAlertDialog", "(Landroid/app/Activity;)V");

  /// from: static public void showAlertDialog(android.app.Activity mainActivity)
  static void showAlertDialog(jni.JObject mainActivity) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_showAlertDialog,
          jni.JniCallType.voidType, [mainActivity.reference]).check();

  static final _id_openCamera = jniAccessors.getStaticMethodIDOf(
      _classRef, "openCamera", "(Landroid/app/Activity;)V");

  /// from: static public void openCamera(android.app.Activity mainActivity)
  static void openCamera(jni.JObject mainActivity) =>
      jniAccessors.callStaticMethodWithArgs(_classRef, _id_openCamera,
          jni.JniCallType.voidType, [mainActivity.reference]).check();
}

class $MyUtilsType extends jni.JObjType<MyUtils> {
  const $MyUtilsType();

  @override
  String get signature =>
      r"Lcom/example/flutter_extend_mz_demo_jinigen/MyUtils;";

  @override
  MyUtils fromRef(jni.JObjectPtr ref) => MyUtils.fromRef(ref);
}

extension $MyUtilsArray on jni.JArray<MyUtils> {
  MyUtils operator [](int index) {
    return (elementType as $MyUtilsType)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, MyUtils value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}

/// from: android.os.Build
class Build extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  Build.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors.getClassOf("android/os/Build");

  /// The type which includes information such as the signature of this class.
  static const type = $BuildType();

  static final _id_BOARD =
      jniAccessors.getStaticFieldIDOf(_classRef, "BOARD", "Ljava/lang/String;");

  /// from: static public final java.lang.String BOARD
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get BOARD => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_BOARD, jni.JniCallType.objectType)
      .object);

  static final _id_BOOTLOADER = jniAccessors.getStaticFieldIDOf(
      _classRef, "BOOTLOADER", "Ljava/lang/String;");

  /// from: static public final java.lang.String BOOTLOADER
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get BOOTLOADER =>
      const jni.JStringType().fromRef(jniAccessors
          .getStaticField(_classRef, _id_BOOTLOADER, jni.JniCallType.objectType)
          .object);

  static final _id_BRAND =
      jniAccessors.getStaticFieldIDOf(_classRef, "BRAND", "Ljava/lang/String;");

  /// from: static public final java.lang.String BRAND
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get BRAND => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_BRAND, jni.JniCallType.objectType)
      .object);

  static final _id_CPU_ABI = jniAccessors.getStaticFieldIDOf(
      _classRef, "CPU_ABI", "Ljava/lang/String;");

  /// from: static public final java.lang.String CPU_ABI
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get CPU_ABI => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_CPU_ABI, jni.JniCallType.objectType)
      .object);

  static final _id_CPU_ABI2 = jniAccessors.getStaticFieldIDOf(
      _classRef, "CPU_ABI2", "Ljava/lang/String;");

  /// from: static public final java.lang.String CPU_ABI2
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get CPU_ABI2 =>
      const jni.JStringType().fromRef(jniAccessors
          .getStaticField(_classRef, _id_CPU_ABI2, jni.JniCallType.objectType)
          .object);

  static final _id_DEVICE = jniAccessors.getStaticFieldIDOf(
      _classRef, "DEVICE", "Ljava/lang/String;");

  /// from: static public final java.lang.String DEVICE
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get DEVICE => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_DEVICE, jni.JniCallType.objectType)
      .object);

  static final _id_DISPLAY = jniAccessors.getStaticFieldIDOf(
      _classRef, "DISPLAY", "Ljava/lang/String;");

  /// from: static public final java.lang.String DISPLAY
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get DISPLAY => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_DISPLAY, jni.JniCallType.objectType)
      .object);

  static final _id_FINGERPRINT = jniAccessors.getStaticFieldIDOf(
      _classRef, "FINGERPRINT", "Ljava/lang/String;");

  /// from: static public final java.lang.String FINGERPRINT
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get FINGERPRINT =>
      const jni.JStringType().fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_FINGERPRINT, jni.JniCallType.objectType)
          .object);

  static final _id_HARDWARE = jniAccessors.getStaticFieldIDOf(
      _classRef, "HARDWARE", "Ljava/lang/String;");

  /// from: static public final java.lang.String HARDWARE
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get HARDWARE =>
      const jni.JStringType().fromRef(jniAccessors
          .getStaticField(_classRef, _id_HARDWARE, jni.JniCallType.objectType)
          .object);

  static final _id_HOST =
      jniAccessors.getStaticFieldIDOf(_classRef, "HOST", "Ljava/lang/String;");

  /// from: static public final java.lang.String HOST
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get HOST => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_HOST, jni.JniCallType.objectType)
      .object);

  static final _id_ID =
      jniAccessors.getStaticFieldIDOf(_classRef, "ID", "Ljava/lang/String;");

  /// from: static public final java.lang.String ID
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get ID => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_ID, jni.JniCallType.objectType)
      .object);

  static final _id_MANUFACTURER = jniAccessors.getStaticFieldIDOf(
      _classRef, "MANUFACTURER", "Ljava/lang/String;");

  /// from: static public final java.lang.String MANUFACTURER
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get MANUFACTURER =>
      const jni.JStringType().fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_MANUFACTURER, jni.JniCallType.objectType)
          .object);

  static final _id_MODEL =
      jniAccessors.getStaticFieldIDOf(_classRef, "MODEL", "Ljava/lang/String;");

  /// from: static public final java.lang.String MODEL
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get MODEL => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_MODEL, jni.JniCallType.objectType)
      .object);

  static final _id_ODM_SKU = jniAccessors.getStaticFieldIDOf(
      _classRef, "ODM_SKU", "Ljava/lang/String;");

  /// from: static public final java.lang.String ODM_SKU
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get ODM_SKU => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_ODM_SKU, jni.JniCallType.objectType)
      .object);

  static final _id_PRODUCT = jniAccessors.getStaticFieldIDOf(
      _classRef, "PRODUCT", "Ljava/lang/String;");

  /// from: static public final java.lang.String PRODUCT
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get PRODUCT => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_PRODUCT, jni.JniCallType.objectType)
      .object);

  static final _id_RADIO =
      jniAccessors.getStaticFieldIDOf(_classRef, "RADIO", "Ljava/lang/String;");

  /// from: static public final java.lang.String RADIO
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get RADIO => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_RADIO, jni.JniCallType.objectType)
      .object);

  static final _id_SERIAL = jniAccessors.getStaticFieldIDOf(
      _classRef, "SERIAL", "Ljava/lang/String;");

  /// from: static public final java.lang.String SERIAL
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get SERIAL => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_SERIAL, jni.JniCallType.objectType)
      .object);

  static final _id_SKU =
      jniAccessors.getStaticFieldIDOf(_classRef, "SKU", "Ljava/lang/String;");

  /// from: static public final java.lang.String SKU
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get SKU => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_SKU, jni.JniCallType.objectType)
      .object);

  static final _id_SOC_MANUFACTURER = jniAccessors.getStaticFieldIDOf(
      _classRef, "SOC_MANUFACTURER", "Ljava/lang/String;");

  /// from: static public final java.lang.String SOC_MANUFACTURER
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get SOC_MANUFACTURER =>
      const jni.JStringType().fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SOC_MANUFACTURER, jni.JniCallType.objectType)
          .object);

  static final _id_SOC_MODEL = jniAccessors.getStaticFieldIDOf(
      _classRef, "SOC_MODEL", "Ljava/lang/String;");

  /// from: static public final java.lang.String SOC_MODEL
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get SOC_MODEL =>
      const jni.JStringType().fromRef(jniAccessors
          .getStaticField(_classRef, _id_SOC_MODEL, jni.JniCallType.objectType)
          .object);

  static final _id_SUPPORTED_32_BIT_ABIS = jniAccessors.getStaticFieldIDOf(
      _classRef, "SUPPORTED_32_BIT_ABIS", "[Ljava/lang/String;");

  /// from: static public final java.lang.String[] SUPPORTED_32_BIT_ABIS
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<jni.JString> get SUPPORTED_32_BIT_ABIS =>
      const jni.JArrayType(jni.JStringType()).fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SUPPORTED_32_BIT_ABIS, jni.JniCallType.objectType)
          .object);

  static final _id_SUPPORTED_64_BIT_ABIS = jniAccessors.getStaticFieldIDOf(
      _classRef, "SUPPORTED_64_BIT_ABIS", "[Ljava/lang/String;");

  /// from: static public final java.lang.String[] SUPPORTED_64_BIT_ABIS
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<jni.JString> get SUPPORTED_64_BIT_ABIS =>
      const jni.JArrayType(jni.JStringType()).fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SUPPORTED_64_BIT_ABIS, jni.JniCallType.objectType)
          .object);

  static final _id_SUPPORTED_ABIS = jniAccessors.getStaticFieldIDOf(
      _classRef, "SUPPORTED_ABIS", "[Ljava/lang/String;");

  /// from: static public final java.lang.String[] SUPPORTED_ABIS
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<jni.JString> get SUPPORTED_ABIS =>
      const jni.JArrayType(jni.JStringType()).fromRef(jniAccessors
          .getStaticField(
              _classRef, _id_SUPPORTED_ABIS, jni.JniCallType.objectType)
          .object);

  static final _id_TAGS =
      jniAccessors.getStaticFieldIDOf(_classRef, "TAGS", "Ljava/lang/String;");

  /// from: static public final java.lang.String TAGS
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get TAGS => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_TAGS, jni.JniCallType.objectType)
      .object);

  static final _id_TIME =
      jniAccessors.getStaticFieldIDOf(_classRef, "TIME", "J");

  /// from: static public final long TIME
  static int get TIME => jniAccessors
      .getStaticField(_classRef, _id_TIME, jni.JniCallType.longType)
      .long;

  static final _id_TYPE =
      jniAccessors.getStaticFieldIDOf(_classRef, "TYPE", "Ljava/lang/String;");

  /// from: static public final java.lang.String TYPE
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get TYPE => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_TYPE, jni.JniCallType.objectType)
      .object);

  /// from: static public final java.lang.String UNKNOWN
  static const UNKNOWN = "unknown";

  static final _id_USER =
      jniAccessors.getStaticFieldIDOf(_classRef, "USER", "Ljava/lang/String;");

  /// from: static public final java.lang.String USER
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString get USER => const jni.JStringType().fromRef(jniAccessors
      .getStaticField(_classRef, _id_USER, jni.JniCallType.objectType)
      .object);

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Build()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_getSerial = jniAccessors.getStaticMethodIDOf(
      _classRef, "getSerial", "()Ljava/lang/String;");

  /// from: static public java.lang.String getSerial()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString getSerial() =>
      const jni.JStringType().fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_getSerial, jni.JniCallType.objectType, []).object);

  static final _id_getFingerprintedPartitions =
      jniAccessors.getStaticMethodIDOf(
          _classRef, "getFingerprintedPartitions", "()Ljava/util/List;");

  /// from: static public java.util.List getFingerprintedPartitions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject getFingerprintedPartitions() =>
      const jni.JObjectType().fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getFingerprintedPartitions,
          jni.JniCallType.objectType, []).object);

  static final _id_getRadioVersion = jniAccessors.getStaticMethodIDOf(
      _classRef, "getRadioVersion", "()Ljava/lang/String;");

  /// from: static public java.lang.String getRadioVersion()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString getRadioVersion() =>
      const jni.JStringType().fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef,
          _id_getRadioVersion,
          jni.JniCallType.objectType, []).object);
}

class $BuildType extends jni.JObjType<Build> {
  const $BuildType();

  @override
  String get signature => r"Landroid/os/Build;";

  @override
  Build fromRef(jni.JObjectPtr ref) => Build.fromRef(ref);
}

extension $BuildArray on jni.JArray<Build> {
  Build operator [](int index) {
    return (elementType as $BuildType)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, Build value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}

/// from: java.util.HashMap
class HashMap<K extends jni.JObject, V extends jni.JObject>
    extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type(
        $K,
        $V,
      );

  final jni.JObjType<K> $K;
  final jni.JObjType<V> $V;

  HashMap.fromRef(
    this.$K,
    this.$V,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors.getClassOf("java/util/HashMap");

  /// The type which includes information such as the signature of this class.
  static $HashMapType<K, V> type<K extends jni.JObject, V extends jni.JObject>(
    jni.JObjType<K> $K,
    jni.JObjType<V> $V,
  ) {
    return $HashMapType(
      $K,
      $V,
    );
  }

  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(IF)V");

  /// from: public void <init>(int i, float f)
  /// The returned object must be deleted after use, by calling the `delete` method.
  HashMap(this.$K, this.$V, int i, double f)
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, [i, f]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(I)V");

  /// from: public void <init>(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  HashMap.ctor1(this.$K, this.$V, int i)
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, [i]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  HashMap.ctor2(this.$K, this.$V)
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor2, []).object);

  static final _id_ctor3 =
      jniAccessors.getMethodIDOf(_classRef, "<init>", "(Ljava/util/Map;)V");

  /// from: public void <init>(java.util.Map map)
  /// The returned object must be deleted after use, by calling the `delete` method.
  HashMap.ctor3(this.$K, this.$V, jni.JObject map)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor3, [map.reference]).object);

  static final _id_size = jniAccessors.getMethodIDOf(_classRef, "size", "()I");

  /// from: public int size()
  int size() => jniAccessors.callMethodWithArgs(
      reference, _id_size, jni.JniCallType.intType, []).integer;

  static final _id_isEmpty =
      jniAccessors.getMethodIDOf(_classRef, "isEmpty", "()Z");

  /// from: public boolean isEmpty()
  bool isEmpty() => jniAccessors.callMethodWithArgs(
      reference, _id_isEmpty, jni.JniCallType.booleanType, []).boolean;

  static final _id_get0 = jniAccessors.getMethodIDOf(
      _classRef, "get", "(Ljava/lang/Object;)Ljava/lang/Object;");

  /// from: public V get(java.lang.Object object)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V get0(jni.JObject object) => $V.fromRef(jniAccessors.callMethodWithArgs(
      reference,
      _id_get0,
      jni.JniCallType.objectType,
      [object.reference]).object);

  static final _id_containsKey = jniAccessors.getMethodIDOf(
      _classRef, "containsKey", "(Ljava/lang/Object;)Z");

  /// from: public boolean containsKey(java.lang.Object object)
  bool containsKey(jni.JObject object) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsKey,
      jni.JniCallType.booleanType,
      [object.reference]).boolean;

  static final _id_put = jniAccessors.getMethodIDOf(_classRef, "put",
      "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");

  /// from: public V put(K object, V object1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V put(K object, V object1) => $V.fromRef(jniAccessors.callMethodWithArgs(
      reference,
      _id_put,
      jni.JniCallType.objectType,
      [object.reference, object1.reference]).object);

  static final _id_putAll =
      jniAccessors.getMethodIDOf(_classRef, "putAll", "(Ljava/util/Map;)V");

  /// from: public void putAll(java.util.Map map)
  void putAll(jni.JObject map) => jniAccessors.callMethodWithArgs(
      reference, _id_putAll, jni.JniCallType.voidType, [map.reference]).check();

  static final _id_remove = jniAccessors.getMethodIDOf(
      _classRef, "remove", "(Ljava/lang/Object;)Ljava/lang/Object;");

  /// from: public V remove(java.lang.Object object)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V remove(jni.JObject object) => $V.fromRef(jniAccessors.callMethodWithArgs(
      reference,
      _id_remove,
      jni.JniCallType.objectType,
      [object.reference]).object);

  static final _id_clear =
      jniAccessors.getMethodIDOf(_classRef, "clear", "()V");

  /// from: public void clear()
  void clear() => jniAccessors.callMethodWithArgs(
      reference, _id_clear, jni.JniCallType.voidType, []).check();

  static final _id_containsValue = jniAccessors.getMethodIDOf(
      _classRef, "containsValue", "(Ljava/lang/Object;)Z");

  /// from: public boolean containsValue(java.lang.Object object)
  bool containsValue(jni.JObject object) => jniAccessors.callMethodWithArgs(
      reference,
      _id_containsValue,
      jni.JniCallType.booleanType,
      [object.reference]).boolean;

  static final _id_keySet =
      jniAccessors.getMethodIDOf(_classRef, "keySet", "()Ljava/util/Set;");

  /// from: public java.util.Set keySet()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject keySet() =>
      const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_keySet, jni.JniCallType.objectType, []).object);

  static final _id_values = jniAccessors.getMethodIDOf(
      _classRef, "values", "()Ljava/util/Collection;");

  /// from: public java.util.Collection values()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject values() =>
      const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_values, jni.JniCallType.objectType, []).object);

  static final _id_entrySet =
      jniAccessors.getMethodIDOf(_classRef, "entrySet", "()Ljava/util/Set;");

  /// from: public java.util.Set entrySet()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject entrySet() =>
      const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_entrySet, jni.JniCallType.objectType, []).object);

  static final _id_getOrDefault = jniAccessors.getMethodIDOf(
      _classRef,
      "getOrDefault",
      "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");

  /// from: public V getOrDefault(java.lang.Object object, V object1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V getOrDefault(jni.JObject object, V object1) =>
      $V.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getOrDefault,
          jni.JniCallType.objectType,
          [object.reference, object1.reference]).object);

  static final _id_putIfAbsent = jniAccessors.getMethodIDOf(
      _classRef,
      "putIfAbsent",
      "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");

  /// from: public V putIfAbsent(K object, V object1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V putIfAbsent(K object, V object1) =>
      $V.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_putIfAbsent,
          jni.JniCallType.objectType,
          [object.reference, object1.reference]).object);

  static final _id_remove1 = jniAccessors.getMethodIDOf(
      _classRef, "remove", "(Ljava/lang/Object;Ljava/lang/Object;)Z");

  /// from: public boolean remove(java.lang.Object object, java.lang.Object object1)
  bool remove1(jni.JObject object, jni.JObject object1) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_remove1,
          jni.JniCallType.booleanType,
          [object.reference, object1.reference]).boolean;

  static final _id_replace = jniAccessors.getMethodIDOf(_classRef, "replace",
      "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z");

  /// from: public boolean replace(K object, V object1, V object2)
  bool replace(K object, V object1, V object2) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_replace,
          jni.JniCallType.booleanType,
          [object.reference, object1.reference, object2.reference]).boolean;

  static final _id_replace1 = jniAccessors.getMethodIDOf(_classRef, "replace",
      "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");

  /// from: public V replace(K object, V object1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V replace1(K object, V object1) => $V.fromRef(jniAccessors.callMethodWithArgs(
      reference,
      _id_replace1,
      jni.JniCallType.objectType,
      [object.reference, object1.reference]).object);

  static final _id_computeIfAbsent = jniAccessors.getMethodIDOf(
      _classRef,
      "computeIfAbsent",
      "(Ljava/lang/Object;Ljava/util/function/Function;)Ljava/lang/Object;");

  /// from: public V computeIfAbsent(K object, java.util.function.Function function)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V computeIfAbsent(K object, jni.JObject function) =>
      $V.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_computeIfAbsent,
          jni.JniCallType.objectType,
          [object.reference, function.reference]).object);

  static final _id_computeIfPresent = jniAccessors.getMethodIDOf(
      _classRef,
      "computeIfPresent",
      "(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;");

  /// from: public V computeIfPresent(K object, java.util.function.BiFunction biFunction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V computeIfPresent(K object, jni.JObject biFunction) =>
      $V.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_computeIfPresent,
          jni.JniCallType.objectType,
          [object.reference, biFunction.reference]).object);

  static final _id_compute = jniAccessors.getMethodIDOf(_classRef, "compute",
      "(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;");

  /// from: public V compute(K object, java.util.function.BiFunction biFunction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V compute(K object, jni.JObject biFunction) =>
      $V.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_compute,
          jni.JniCallType.objectType,
          [object.reference, biFunction.reference]).object);

  static final _id_merge = jniAccessors.getMethodIDOf(_classRef, "merge",
      "(Ljava/lang/Object;Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;");

  /// from: public V merge(K object, V object1, java.util.function.BiFunction biFunction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  V merge(K object, V object1, jni.JObject biFunction) =>
      $V.fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_merge,
          jni.JniCallType.objectType,
          [object.reference, object1.reference, biFunction.reference]).object);

  static final _id_forEach = jniAccessors.getMethodIDOf(
      _classRef, "forEach", "(Ljava/util/function/BiConsumer;)V");

  /// from: public void forEach(java.util.function.BiConsumer biConsumer)
  void forEach(jni.JObject biConsumer) => jniAccessors.callMethodWithArgs(
      reference,
      _id_forEach,
      jni.JniCallType.voidType,
      [biConsumer.reference]).check();

  static final _id_replaceAll = jniAccessors.getMethodIDOf(
      _classRef, "replaceAll", "(Ljava/util/function/BiFunction;)V");

  /// from: public void replaceAll(java.util.function.BiFunction biFunction)
  void replaceAll(jni.JObject biFunction) => jniAccessors.callMethodWithArgs(
      reference,
      _id_replaceAll,
      jni.JniCallType.voidType,
      [biFunction.reference]).check();

  static final _id_clone =
      jniAccessors.getMethodIDOf(_classRef, "clone", "()Ljava/lang/Object;");

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject clone() =>
      const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_clone, jni.JniCallType.objectType, []).object);
}

class $HashMapType<K extends jni.JObject, V extends jni.JObject>
    extends jni.JObjType<HashMap<K, V>> {
  final jni.JObjType<K> $K;
  final jni.JObjType<V> $V;

  const $HashMapType(
    this.$K,
    this.$V,
  );

  @override
  String get signature => r"Ljava/util/HashMap;";

  @override
  HashMap<K, V> fromRef(jni.JObjectPtr ref) => HashMap.fromRef($K, $V, ref);
}

extension $HashMapArray<K extends jni.JObject, V extends jni.JObject>
    on jni.JArray<HashMap<K, V>> {
  HashMap<K, V> operator [](int index) {
    return (elementType as $HashMapType<K, V>)
        .fromRef(elementAt(index, jni.JniCallType.objectType).object);
  }

  void operator []=(int index, HashMap<K, V> value) {
    (this as jni.JArray<jni.JObject>)[index] = value;
  }
}
